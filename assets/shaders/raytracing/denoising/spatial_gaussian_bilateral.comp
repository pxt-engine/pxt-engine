#version 460
#extension GL_ARB_separate_shader_objects : enable

// Define workgroup size
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform Push {
    uint frameCount;
    uint accumulationCount;
    float temporalAlpha;
    uint spatialKernelRadius;
    float spatialSigmaColor;
    float spatialSigmaSpace;
    bool isTemporalEnabled;
    bool isSpatialEnabled;
} push;

// Descriptor Set 0: Spatial Filter Pass Bindings
layout(set = 0, binding = 0) uniform sampler2D temporalOutputSampler; // input from temporal filter
layout(set = 0, binding = 1) uniform sampler2D newNoisyFrameForGuidanceSampler; // For other techniques
layout(set = 0, binding = 2, rgba16f) uniform image2D finalDenoisedOutputImage; // Output image

// Function to generate a 1D Gaussian weight
float gaussian(float x, float sigma) {
    return exp(-(x * x) / (2.0 * sigma * sigma));
}

void main() {
    // Get the global invocation ID, which corresponds to the pixel coordinate
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    ivec2 imageDimensions = imageSize(finalDenoisedOutputImage);

    // Boundary check
    if (texelCoord.x >= imageDimensions.x || texelCoord.y >= imageDimensions.y) {
        return;
    }

    // If the spatial filter is not enabled, we can just save the temporal filtering color.
    if (!push.isSpatialEnabled) {
        vec4 temporalColor = texture(temporalOutputSampler, texelCoord);
        imageStore(finalDenoisedOutputImage, texelCoord, temporalColor);
        return;
    }

    vec3 finalColor = vec3(0.0);
    float totalWeight = 0.0;

    // --- BILATERAL FILTER ---
    // Combines spatial and color information to denoise the image.
    // The neighbors gain more weight the more similar they are in color
    // and closer in space to the center pixel.

    const int kernelRadius = int(push.spatialKernelRadius);

    // Fetch the center pixel's color to use as a reference.
    vec3 centerColor = texture(temporalOutputSampler, texelCoord).rgb;

    for (int y = -kernelRadius; y <= kernelRadius; ++y) {
        for (int x = -kernelRadius; x <= kernelRadius; ++x) {
            ivec2 currentOffset = ivec2(x, y);
            ivec2 currentCoord = texelCoord + currentOffset;

            if (currentCoord.x >= 0 && currentCoord.x < imageDimensions.x &&
                currentCoord.y >= 0 && currentCoord.y < imageDimensions.y) {

                // --- SPATIAL WEIGHT ---
                float distanceSq = float(x*x + y*y);
                float spaceWeight = exp(-distanceSq / (2.0 * push.spatialSigmaSpace * push.spatialSigmaSpace));

                // Sample the neighbor pixel
                vec3 currentSample = texture(temporalOutputSampler, currentCoord).rgb;

                // --- COLOR WEIGHT ---
                // Calculate the squared color distance in RGB space.
                float colorDistSq = dot(centerColor - currentSample, centerColor - currentSample);
                float colorWeight = exp(-colorDistSq / (2.0 * push.spatialSigmaColor * push.spatialSigmaColor));
                
                // --- COMBINE WEIGHTS ---
                float finalWeight = spaceWeight * colorWeight;

                finalColor += currentSample * finalWeight;
                totalWeight += finalWeight;
            }
        }
    }

    // Normalize the final color by the sum of all weights
    if (totalWeight > 0.0) {
        finalColor /= totalWeight;
    }

    // Store the final denoised color to the output image
    imageStore(finalDenoisedOutputImage, texelCoord, vec4(finalColor, 1.0));
}