#version 460
#extension GL_ARB_separate_shader_objects : enable

// Define workgroup size
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform Push {
    uint frameCount;
    uint accumulationCount;
    float temporalAlpha;
    uint spatialKernelRadius;
    float spatialSigmaColor;
    float spatialSigmaSpace;
    bool isTemporalEnabled;
    bool isSpatialEnabled;
} push;

// Descriptor Set 0: Spatial Filter Pass Bindings
layout(set = 0, binding = 0) uniform sampler2D temporalOutputSampler; // input from temporal filter
layout(set = 0, binding = 1) uniform sampler2D newNoisyFrameForGuidanceSampler; // For other techniques
layout(set = 0, binding = 2, rgba16f) uniform image2D finalDenoisedOutputImage; // Output image

// Function to generate a 1D Gaussian weight
float gaussian(float x, float sigma) {
    return exp(-(x * x) / (2.0 * sigma * sigma));
}

void main() {
    // Get the global invocation ID, which corresponds to the pixel coordinate
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    // Read the dimensions of the output image
    ivec2 imageDimensions = imageSize(finalDenoisedOutputImage);

    // Boundary check
    if (texelCoord.x >= imageDimensions.x || texelCoord.y >= imageDimensions.y) {
        return;
    }

    // If the spatial filter is not enabled, we can just save the temporal filtering color.
    if (!push.isSpatialEnabled) {
        vec4 temporalColor = texture(temporalOutputSampler, texelCoord);
        imageStore(finalDenoisedOutputImage, texelCoord, temporalColor);
        return;
    }

    vec3 finalColor = vec3(0.0);
    float totalWeight = 0.0;

    const int kernelRadius = int(push.spatialKernelRadius);

    // A simple 2D Gaussian filter is separable, meaning it can be done with two 1D passes
    // (one horizontal, one vertical) for better performance.
    // However, for simplicity and clarity, this example uses a single 2D pass.
    for (int y = -kernelRadius; y <= kernelRadius; ++y) {
        for (int x = -kernelRadius; x <= kernelRadius; ++x) {
            ivec2 currentOffset = ivec2(x, y);
            ivec2 currentCoord = texelCoord + currentOffset;

            // Check if the current pixel is within the image bounds
            if (currentCoord.x >= 0 && currentCoord.x < imageDimensions.x &&
                currentCoord.y >= 0 && currentCoord.y < imageDimensions.y) {

                // Calculate the 2D Gaussian weight
                float distanceSq = float(currentOffset.x * currentOffset.x + currentOffset.y * currentOffset.y);
                // The `spatialSigmaSpace` is the standard deviation (sigma) for our Gaussian
                float weight = exp(-distanceSq / (2.0 * push.spatialSigmaSpace * push.spatialSigmaSpace));

                // Sample the color from the input image at the current offset
                vec3 currentSample = texture(temporalOutputSampler, currentCoord).rgb;

                finalColor += currentSample * weight;
                totalWeight += weight;
            }
        }
    }

    // Normalize the final color by the sum of all weights
    if (totalWeight > 0.0) {
        finalColor /= totalWeight;
    }

    // Store the final denoised color to the output image
    imageStore(finalDenoisedOutputImage, texelCoord, vec4(finalColor, 1.0));
}