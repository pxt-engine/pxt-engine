#version 460
#extension GL_ARB_separate_shader_objects : enable

// Define workgroup size
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
    uint frameCount;
    float temporalAlpha;
    float spatialSigmaColor;
    float spatialSigmaSpace;
} pushConstants;

// Descriptor Set 0: Spatial Filter Pass Bindings
layout(set = 0, binding = 0) uniform sampler2D temporalOutputSampler; // Unused in this example
layout(set = 0, binding = 1) uniform sampler2D newNoisyFrameForGuidanceSampler; // Input image
layout(set = 0, binding = 2, rgba16f) uniform image2D finalDenoisedOutputImage; // Output image

// Define a kernel size. A 5x5 kernel is a good balance of performance and quality.
#define KERNEL_RADIUS 2
#define KERNEL_SIZE (KERNEL_RADIUS * 2 + 1)

// Function to generate a 1D Gaussian weight
float gaussian(float x, float sigma) {
    return exp(-(x * x) / (2.0 * sigma * sigma));
}

void main() {
    // Get the global invocation ID, which corresponds to the pixel coordinate
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    // Read the dimensions of the output image
    ivec2 imageDimensions = imageSize(finalDenoisedOutputImage);

    // Boundary check
    if (texelCoord.x >= imageDimensions.x || texelCoord.y >= imageDimensions.y) {
        return;
    }

    vec3 finalColor = vec3(0.0);
    float totalWeight = 0.0;

    // A simple 2D Gaussian filter is separable, meaning it can be done with two 1D passes
    // (one horizontal, one vertical) for better performance.
    // However, for simplicity and clarity, this example uses a single 2D pass.
    for (int y = -KERNEL_RADIUS; y <= KERNEL_RADIUS; ++y) {
        for (int x = -KERNEL_RADIUS; x <= KERNEL_RADIUS; ++x) {
            ivec2 currentOffset = ivec2(x, y);
            ivec2 currentCoord = texelCoord + currentOffset;

            // Check if the current pixel is within the image bounds
            if (currentCoord.x >= 0 && currentCoord.x < imageDimensions.x &&
                currentCoord.y >= 0 && currentCoord.y < imageDimensions.y) {

                // Calculate the 2D Gaussian weight
                float distanceSq = float(currentOffset.x * currentOffset.x + currentOffset.y * currentOffset.y);
                // The `spatialSigmaSpace` is the standard deviation (sigma) for our Gaussian
                float weight = exp(-distanceSq / (2.0 * pushConstants.spatialSigmaSpace * pushConstants.spatialSigmaSpace));

                // Sample the color from the input image at the current offset
                vec3 currentSample = texture(newNoisyFrameForGuidanceSampler, currentCoord).rgb;

                finalColor += currentSample * weight;
                totalWeight += weight;
            }
        }
    }

    // Normalize the final color by the sum of all weights
    if (totalWeight > 0.0) {
        finalColor /= totalWeight;
    }

    // Store the final denoised color to the output image
    imageStore(finalDenoisedOutputImage, texelCoord, vec4(finalColor, 1.0));
}